// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: writes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearActiveProposals = `-- name: ClearActiveProposals :exec
delete from eth_active_proposals
`

func (q *Queries) ClearActiveProposals(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearActiveProposals)
	return err
}

const clearRegisteredEndpoints = `-- name: ClearRegisteredEndpoints :exec
delete from eth_registered_endpoints
`

func (q *Queries) ClearRegisteredEndpoints(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearRegisteredEndpoints)
	return err
}

const clearServiceProviders = `-- name: ClearServiceProviders :exec
delete from eth_service_providers
`

func (q *Queries) ClearServiceProviders(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearServiceProviders)
	return err
}

const clearStaked = `-- name: ClearStaked :exec
delete from eth_staked
`

func (q *Queries) ClearStaked(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearStaked)
	return err
}

const deleteActiveProposal = `-- name: DeleteActiveProposal :exec
delete from eth_active_proposals
where id = $1
`

func (q *Queries) DeleteActiveProposal(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteActiveProposal, id)
	return err
}

const deleteRegisteredEndpoint = `-- name: DeleteRegisteredEndpoint :exec
delete from eth_registered_endpoints
where id = $1 and endpoint = $2 and owner = $3 and service_type = $4
`

type DeleteRegisteredEndpointParams struct {
	ID          int32  `json:"id"`
	Endpoint    string `json:"endpoint"`
	Owner       string `json:"owner"`
	ServiceType string `json:"service_type"`
}

func (q *Queries) DeleteRegisteredEndpoint(ctx context.Context, arg DeleteRegisteredEndpointParams) error {
	_, err := q.db.Exec(ctx, deleteRegisteredEndpoint,
		arg.ID,
		arg.Endpoint,
		arg.Owner,
		arg.ServiceType,
	)
	return err
}

const insertActiveProposal = `-- name: InsertActiveProposal :exec
insert into eth_active_proposals (id, proposer, submission_block_number, target_contract_registry_key, target_contract_address, call_value, function_signature, call_data)
values ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertActiveProposalParams struct {
	ID                        int64  `json:"id"`
	Proposer                  string `json:"proposer"`
	SubmissionBlockNumber     int64  `json:"submission_block_number"`
	TargetContractRegistryKey string `json:"target_contract_registry_key"`
	TargetContractAddress     string `json:"target_contract_address"`
	CallValue                 int64  `json:"call_value"`
	FunctionSignature         string `json:"function_signature"`
	CallData                  string `json:"call_data"`
}

func (q *Queries) InsertActiveProposal(ctx context.Context, arg InsertActiveProposalParams) error {
	_, err := q.db.Exec(ctx, insertActiveProposal,
		arg.ID,
		arg.Proposer,
		arg.SubmissionBlockNumber,
		arg.TargetContractRegistryKey,
		arg.TargetContractAddress,
		arg.CallValue,
		arg.FunctionSignature,
		arg.CallData,
	)
	return err
}

const insertRegisteredEndpoint = `-- name: InsertRegisteredEndpoint :exec
insert into eth_registered_endpoints (id, service_type, owner, delegate_wallet, endpoint, blocknumber, registered_at)
values ($1, $2, $3, $4, $5, $6, $7)
`

type InsertRegisteredEndpointParams struct {
	ID             int32            `json:"id"`
	ServiceType    string           `json:"service_type"`
	Owner          string           `json:"owner"`
	DelegateWallet string           `json:"delegate_wallet"`
	Endpoint       string           `json:"endpoint"`
	Blocknumber    int64            `json:"blocknumber"`
	RegisteredAt   pgtype.Timestamp `json:"registered_at"`
}

func (q *Queries) InsertRegisteredEndpoint(ctx context.Context, arg InsertRegisteredEndpointParams) error {
	_, err := q.db.Exec(ctx, insertRegisteredEndpoint,
		arg.ID,
		arg.ServiceType,
		arg.Owner,
		arg.DelegateWallet,
		arg.Endpoint,
		arg.Blocknumber,
		arg.RegisteredAt,
	)
	return err
}

const insertServiceProvider = `-- name: InsertServiceProvider :exec
insert into eth_service_providers (address, deployer_stake, deployer_cut, valid_bounds, number_of_endpoints, min_account_stake, max_account_stake)
values ($1, $2, $3, $4, $5, $6, $7)
`

type InsertServiceProviderParams struct {
	Address           string `json:"address"`
	DeployerStake     int64  `json:"deployer_stake"`
	DeployerCut       int64  `json:"deployer_cut"`
	ValidBounds       bool   `json:"valid_bounds"`
	NumberOfEndpoints int32  `json:"number_of_endpoints"`
	MinAccountStake   int64  `json:"min_account_stake"`
	MaxAccountStake   int64  `json:"max_account_stake"`
}

func (q *Queries) InsertServiceProvider(ctx context.Context, arg InsertServiceProviderParams) error {
	_, err := q.db.Exec(ctx, insertServiceProvider,
		arg.Address,
		arg.DeployerStake,
		arg.DeployerCut,
		arg.ValidBounds,
		arg.NumberOfEndpoints,
		arg.MinAccountStake,
		arg.MaxAccountStake,
	)
	return err
}

const upsertServiceProvider = `-- name: UpsertServiceProvider :exec
insert into eth_service_providers (address, deployer_stake, deployer_cut, valid_bounds, number_of_endpoints, min_account_stake, max_account_stake)
values ($1, $2, $3, $4, $5, $6, $7)
on conflict (address) do update
set 
    deployer_stake = $2,
    deployer_cut = $3,
    valid_bounds = $4,
    number_of_endpoints = $5,
    min_account_stake = $6,
    max_account_stake = $7
`

type UpsertServiceProviderParams struct {
	Address           string `json:"address"`
	DeployerStake     int64  `json:"deployer_stake"`
	DeployerCut       int64  `json:"deployer_cut"`
	ValidBounds       bool   `json:"valid_bounds"`
	NumberOfEndpoints int32  `json:"number_of_endpoints"`
	MinAccountStake   int64  `json:"min_account_stake"`
	MaxAccountStake   int64  `json:"max_account_stake"`
}

func (q *Queries) UpsertServiceProvider(ctx context.Context, arg UpsertServiceProviderParams) error {
	_, err := q.db.Exec(ctx, upsertServiceProvider,
		arg.Address,
		arg.DeployerStake,
		arg.DeployerCut,
		arg.ValidBounds,
		arg.NumberOfEndpoints,
		arg.MinAccountStake,
		arg.MaxAccountStake,
	)
	return err
}

const upsertStaked = `-- name: UpsertStaked :exec
insert into eth_staked (address, total_staked)
values ($1, $2)
on conflict (address) do update
set total_staked = $2
`

type UpsertStakedParams struct {
	Address     string `json:"address"`
	TotalStaked int64  `json:"total_staked"`
}

func (q *Queries) UpsertStaked(ctx context.Context, arg UpsertStakedParams) error {
	_, err := q.db.Exec(ctx, upsertStaked, arg.Address, arg.TotalStaked)
	return err
}
